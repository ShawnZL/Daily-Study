# Regular Expression

## 简介

```
^[0-9]+abc$
```

1. `^` 匹配的开始位置
2. `[0-9]+` 匹配多个数字，`[0-9]` 匹配单个数字，`+` 匹配一个或多个
3. `abc$` 匹配字母 `abc` 并且以 `abc` 结尾，`$` 为匹配的输入字符的结束位置

```
^[a-z0-9_-]{3, 15}$
```

1. `[a-z0-9_-]` 匹配字母、数字、`_` 和 `-`
2. `{3, 15}` 匹配长度为 3 - 15个

以上的正则表达式可以匹配 **runoob、runoob1、run-oob、run_oob**， 但不匹配 **ru**，因为它包含的字母太短了，小于 3 个无法匹配。也不匹配 **runoob$**, 因为它包含特殊字符。

匹配以数字开头，并以 abc 结尾的字符串。

```
^[0-9]+abc$
```

### 使用正则表达式

1. 测试字符串内的模式
2. 替换文本
3. 基于模式匹配从字符串中提取子字符串

## 语法

正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串。

正则表达式是由普通字符（例如字符a-z）以及特殊字符（成为“元字符”）组成的文字模式

### 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可以打印字符。包括所有大小写字母、所有数字、所有标点符号和一些其他符号。

| 字符     | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| `[ABC]`  | 匹配 `[...]` 中的所有字符串                                  |
| `[^ABC]` | 匹配除了 `[...]` 中字符的所有字符                            |
| `[A-Z]`  | `[A-Z]` 表示一个区间，匹配所有大写字母，                     |
| `.`      | 匹配除换行符（\n, \r）之外的任何单个字符，相当于 `[^\n\r]`   |
| `[\s\S]` | 匹配所有。`\s` 匹配所有空白符，包括换行，`\S` 非空白符，不包括换行 |
| `\w`     | 匹配数字、字母、下划线。等价于`[A-Za-Z0-9_]`                 |
| `\d`     | 匹配一个数字字符。等价于[0 - 9]                              |
| `\D`     | 匹配一个非数字字符。等价于\[^0 - 9]                          |

#### 非打印字符

非打印字符也可以是正则表达式的组成部分。非打印字符的转义序列

| 字符  | 描述                                                         |
| ----- | :----------------------------------------------------------- |
| `\f`  | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| `\cx` | `\cx`匹配由x指明的控制字符，例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| `\n`  | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| `\r`  | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| `\s`  | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 |
| `\S`  | 匹配任何非空白字符。等价于 \[^ \f\n\r\t\v]。                 |
| `\t`  | 匹配一个制表符。等价于\x09 和 \cI。                          |
| `\v`  | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |

#### 特殊字符

有特殊含义字符。如果在字符中查找，需要进行转义，在表格前加 `\` 

| 特别字符 | 描述                                                         |
| :------- | ------------------------------------------------------------ |
| `$`      | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 `\n` 或 `\r`。要匹配 $ 字符本身，请使用 `\$`。 |
| `()`     | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\( `和 `\)`。 |
| `*`      | 匹配前面的子表达式零次或多次。要匹配 `*` 字符，请使用 `\*`。 |
| `+`      | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。     |
| `.`      | 匹配除了换行符 `\n` 之外的任何单字符                         |
| `[`      | 标记一个中括号表达式的开始。要匹配 `[`，请使用 `\[`。        |
| `?`      | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 `?` 字符，请使用 `\?`。 |
| `\`      | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， `'n'` 匹配字符 `'n'`。`'\n'` 匹配换行符。序列 `\\` 匹配 `\`，而 `\(` 则匹配 `(`。 |
| `^`      | 匹配输入字符串的开始位置（方括号中除外），当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 `^` 字符本身，请使用 `\^`。 |
| `{`      | 标记限定符表达式的开始。要匹配 `{`，请使用 `\{`。            |
| `|`      | 指明两项之间的一个选择。要匹配`|`，请使用 `\|`。             |

#### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配，有 ***** 或 **+** 或 **?** 或 **{n}** 或 **{n,}** 或 **{n,m}** 共6种。

| 字符     | 描述                                                         |
| :------- | ------------------------------------------------------------ |
| `*`      | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| `+`      | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| `?`      | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| `{n}`    | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| `{n,}`   | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| `{n, m}` | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

限定符出现在范围表达式之后。因此，它应用于整个范围表达式。

`*` 和 `+` 限定符都是贪婪的，因为它们会尽可能多的匹配文字。

```
<.*>
<h1>RUNOOB-菜鸟教程</h1> //全部匹配

<.*?>
<h1>RUNOOB-菜鸟教程</h1> //只匹配<h1> 和 </h1>
```

**通过在 `*`、`+` 或 `?` 限定符之后放置 `?`，该表达式从"贪婪"表达式转换为"非贪婪"表达式或者最小匹配。**

#### 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

定位符用来描述字符串或单词的边界，`^` 和 `$` 分别指字符串的开始与结束，`\b` 描述单词的前或后边界，`\B` 表示非单词边界。

| 字符 | 描述                                                         |
| :--- | ------------------------------------------------------------ |
| `^`  | 匹配输入字符串开始的位置。**如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。** |
| `$`  | 匹配输入字符串结尾的位置。**如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。** |
| `\b` | 匹配一个单词边界，即字与空格间的位置。                       |
| `\B` | 非单词边界匹配                                               |

**注意：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 `^*`之类的表达式。**

**若要匹配一行文本开始处的文本，请在正则表达式的开始使用 `^` 字符。不要将 `^` 的这种用法与中括号表达式内的用法混淆。**

**若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 `$` 字符。**

##### 例子

**若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首。但是真正的标题是该行中仅有的文本。它既出现在行首又出现在同一行的结尾，严谨应该是按照第二个进行匹配**

```
^Chapter [1-9][0-9]{0,1}
^Chapter [1-9][0-9]{0,1}$
```

**`\b` 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单纯的开始处查找匹配项。如果位于字符串的结尾，它在单词的结尾处查找匹配项**

```
\bCha #匹配Cha开头单词
ter\b #匹配ter结尾单词
```

**下面的表达式匹配`Chapter` 中的字符串`apt`，但是不匹配 `aptitude` 中的字符串 `apt`,字符串 apt 出现在单词 `Chapter` 中的非单词边界处，但出现在单词 `aptitude` 中的单词边界处。对于 `\B` 非单词边界运算符，不可以匹配单词的开头或结尾**

```
\Bapt
```

#### 选择

用圆括号`()` 将所有选择项扩起来，相邻的选择项之间使用 `|` 分隔

`()` 表示捕获分组，`()` 会把每个分组里的匹配的值保存起来，**多个匹配值可以通过数字 `n` 来查看 （`n` 是一个数字，表示第 `n` 个捕获组的内容）**

##### 例子

```
(([1-9])([a-z]+)) #匹配一个数字开头多字母(非零字母)结尾串
```

![](https://www.runoob.com/wp-content/uploads/2014/03/82A7298A-2A94-49E3-AA27-A7778EE89711.jpg)

**但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 `?:` 放在第一个选项前来消除这种副作用。**

**其中`?:` 是非捕获元之一，另外两个是 `?=` 和 `?!`**，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串

##### 先行断言和后行断言

先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为**"零宽"**。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。

`?=`  & `?<=` & `?!` & `?<!`

###### `?=`正向先行断言

`exp1(?= exp2)`    查找 exp2 前面的 exp1

###### `?<=`负向先行断言

`(?<=exp2)exp1`    查找exp2 后面的 exp1

###### `?!` 正向后行断言

`exp1(?!exp2) `       查找后面不是exp2的exp1

###### `?<! ` 负向后行断言

`(?<!exp2)exp1`     查找前面不是exp2 的 exp1

###### 两方面理解：

- **1、关于先行(lookahead)和后行(lookbehind)：**正则表达式引擎在执行字符串和表达式匹配时，会从头到尾（从前到后）连续扫描字符串中的字符，设想有一个扫描指针指向字符边界处并随匹配过程移动。先行断言，是当扫描指针位于某处时，引擎会尝试匹配指针还未扫过的字符，先于指针到达该字符，故称为先行。后行断言，引擎会尝试匹配指针已扫过的字符，后于指针到达该字符，故称为后行。
- **2、关于正向(positive)和负向(negative)：**正向就表示匹配括号中的表达式，负向表示不匹配。

###### 形成记忆：

- **1、先行和后行：**后行断言 **(?<=pattern)、(?<!pattern)** 中，有个小于号，同时也是箭头，对于自左至右的文本方向，这个箭头是指向后的，这也比较符合我们的习惯。把小于号去掉，就是先行断言。
- **2、正向和负向：**不等于 **(!=)**、逻辑非 **(!)** 都是用 **!**号来表示，所以有 **!** 号的形式表示不匹配、负向；将 **!** 号换成 **=** 号，就表示匹配、正向。

我们经常用正则表达式来检测一个字符串中包含某个子串，要表示一个字符串中不包含某个字符或某些字符也很容易，用 **[^...]** 形式就可以了。要表示一个字符串中不包含某个子串（由字符序列构成）就需要断言语句

###### **例如判断一句话中包含 this，但不包含 that**。

```
^((?<!that).)*this((?<!that).)*$
或 
^(.(?!that))*this(.(?!that))*$
```

如一句话以 **that** 开头、以 **that** 结尾、**that** 和 **this** 连在一起时，上述表达式就可能不胜任了

```
^(.(?<!that))*this(.(?<!that))*$
^(.(?<!that))*this((?!that).)*$
^((?!that).)*this(.(?<!that))*$
^((?!that).)*this((?!that).)*$
```

[正则表达式的先行断言(lookahead)和后行断言(lookbehind)](https://www.runoob.com/w3cnote/reg-lookahead-lookbehind.html)

#### 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲空间，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 **\n** 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。可以使用非捕获元字符 **?:**、**?=** 或 **?!** 来重写捕获，忽略对相关匹配的保存。

##### 例子

`\b([a-z]+) \1\b` 

其中`([a-z]+)` 表示匹配一个或多个字母。**第二部分是对以前捕获的子匹配的引用，即，单词的第二个匹配项正好由括号表达式匹配。`\1` 表示第一个子匹配项**，`\b` 作用单词边界元字符确保只检测整个单词。

`(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)`

解析URL

- 第一个括号子表达式包含 `http`
- 第二个括号子表达式包含 `www.runoob.com`
- 第三个括号子表达式包含 `:80`
- 第四个括号子表达式包含 `/html/html-tutorial.html`

## 修饰符

| 修饰符 | 含义                                 | 描述                                                         |
| ------ | :----------------------------------- | ------------------------------------------------------------ |
| i      | ignore - 不区分大小写                | 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 |
| g      | global- 全局匹配                     | 查找所有的匹配项。                                           |
| m      | multi line - 多行匹配                | 使边界字符 `^` 和 `$` 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 |
| s      | 特殊字符圆点 **.** 中包含换行符 `\n` | 默认情况下的圆点 **.** 是 匹配除换行符 **\n** 之外的任何字符，加上 **s** 修饰符之后, **.** 中包含换行符 \n。 |

## 元字符表格

[todo](https://www.runoob.com/regexp/regexp-metachar.html)