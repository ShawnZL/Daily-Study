# Regular Expression

## 简介

```
^[0-9]+abc$
```

1. `^` 匹配的开始位置
2. `[0-9]+` 匹配多个数字，`[0-9]` 匹配单个数字，`+` 匹配一个或多个
3. `abc$` 匹配字母 `abc` 并且以 `abc` 结尾，`$` 为匹配的输入字符的结束位置

```
^[a-z0-9_-]{3, 15}$
```

1. `[a-z0-9_-]` 匹配字母、数字、`_` 和 `-`
2. `{3, 15}` 匹配长度为 3 - 15个

以上的正则表达式可以匹配 **runoob、runoob1、run-oob、run_oob**， 但不匹配 **ru**，因为它包含的字母太短了，小于 3 个无法匹配。也不匹配 **runoob$**, 因为它包含特殊字符。

匹配以数字开头，并以 abc 结尾的字符串。

```
^[0-9]+abc$
```

### 使用正则表达式

1. 测试字符串内的模式
2. 替换文本
3. 基于模式匹配从字符串中提取子字符串

## 语法

正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串。

正则表达式是由普通字符（例如字符a-z）以及特殊字符（成为“元字符”）组成的文字模式

### 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可以打印字符。包括所有大小写字母、所有数字、所有标点符号和一些其他符号。

| 字符     | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| `[ABC]`  | 匹配 `[...]` 中的所有字符串                                  |
| `[^ABC]` | 匹配除了 `[...]` 中字符的所有字符                            |
| `[A-Z]`  | `[A-Z]` 表示一个区间，匹配所有大写字母，                     |
| `.`      | 匹配除换行符（\n, \r）之外的任何单个字符，相当于 `[^\n\r]`   |
| `[\s\S]` | 匹配所有。`\s` 匹配所有空白符，包括换行，`\S` 非空白符，不包括换行 |
| `\w`     | 匹配数字、字母、下划线。等价于`[A-Za-Z0-9_]`                 |
| `\d`     | 匹配一个数字字符。等价于[0 - 9]                              |
| `\D`     | 匹配一个非数字字符。等价于\[^0 - 9]                          |

#### 非打印字符

非打印字符也可以是正则表达式的组成部分。非打印字符的转义序列

| 字符  | 描述                                                         |
| ----- | :----------------------------------------------------------- |
| `\f`  | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| `\cx` | `\cx`匹配由x指明的控制字符，例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| `\n`  | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| `\r`  | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| `\s`  | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 |
| `\S`  | 匹配任何非空白字符。等价于 \[^ \f\n\r\t\v]。                 |
| `\t`  | 匹配一个制表符。等价于\x09 和 \cI。                          |
| `\v`  | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |

#### 特殊字符

有特殊含义字符。如果在字符中查找，需要进行转义，在表格前加 `\` 

| 特别字符 | 描述                                                         |
| :------- | ------------------------------------------------------------ |
| `$`      | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 `\n` 或 `\r`。要匹配 $ 字符本身，请使用 `\$`。 |
| `()`     | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\( `和 `\)`。 |
| `*`      | 匹配前面的子表达式零次或多次。要匹配 `*` 字符，请使用 `\*`。 |
| `+`      | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。     |
| `.`      | 匹配除了换行符 `\n` 之外的任何单字符                         |
| `[`      | 标记一个中括号表达式的开始。要匹配 `[`，请使用 `\[`。        |
| `?`      | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 `?` 字符，请使用 `\?`。 |
| `\`      | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， `'n'` 匹配字符 `'n'`。`'\n'` 匹配换行符。序列 `\\` 匹配 `\`，而 `\(` 则匹配 `(`。 |
| `^`      | 匹配输入字符串的开始位置（方括号中除外），当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 `^` 字符本身，请使用 `\^`。 |
| `{`      | 标记限定符表达式的开始。要匹配 `{`，请使用 `\{`。            |
| `|`      | 指明两项之间的一个选择。要匹配`|`，请使用 `\|`。             |

#### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配，有 ***** 或 **+** 或 **?** 或 **{n}** 或 **{n,}** 或 **{n,m}** 共6种。

| 字符     | 描述                                                         |
| :------- | ------------------------------------------------------------ |
| `*`      | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| `+`      | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| `?`      | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| `{n}`    | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| `{n,}`   | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| `{n, m}` | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

限定符出现在范围表达式之后。因此，它应用于整个范围表达式。

`*` 和 `+` 限定符都是贪婪的，因为它们会尽可能多的匹配文字。

```
<.*>
<h1>RUNOOB-菜鸟教程</h1> //全部匹配

<.*?>
<h1>RUNOOB-菜鸟教程</h1> //只匹配<h1> 和 </h1>
```

**通过在 `*`、`+` 或 `?` 限定符之后放置 `?`，该表达式从"贪婪"表达式转换为"非贪婪"表达式或者最小匹配。**

#### 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

定位符用来描述字符串或单词的边界，`^` 和 `$` 分别指字符串的开始与结束，`\b` 描述单词的前或后边界，`\B` 表示非单词边界。

| 字符 | 描述                                                         |
| :--- | ------------------------------------------------------------ |
| `^`  | 匹配输入字符串开始的位置。**如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。** |
| `$`  | 匹配输入字符串结尾的位置。**如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。** |
| `\b` | 匹配一个单词边界，即字与空格间的位置。                       |
| `\B` | 非单词边界匹配                                               |

**注意：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 `^*`之类的表达式。**

**若要匹配一行文本开始处的文本，请在正则表达式的开始使用 `^` 字符。不要将 `^` 的这种用法与中括号表达式内的用法混淆。**

**若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 `$` 字符。**

##### 例子

**若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首。但是真正的标题是该行中仅有的文本。它既出现在行首又出现在同一行的结尾，严谨应该是按照第二个进行匹配**

```
^Chapter [1-9][0-9]{0,1}
^Chapter [1-9][0-9]{0,1}$
```

**`\b` 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单纯的开始处查找匹配项。如果位于字符串的结尾，它在单词的结尾处查找匹配项**

```
\bCha #匹配Cha开头单词
ter\b #匹配ter结尾单词
```

**下面的表达式匹配`Chapter` 中的字符串`apt`，但是不匹配 `aptitude` 中的字符串 `apt`,字符串 apt 出现在单词 `Chapter` 中的非单词边界处，但出现在单词 `aptitude` 中的单词边界处。对于 `\B` 非单词边界运算符，不可以匹配单词的开头或结尾**

```
\Bapt
```

#### 选择

用圆括号`()` 将所有选择项扩起来，相邻的选择项之间使用 `|` 分隔

`()` 表示捕获分组，`()` 会把每个分组里的匹配的值保存起来，**多个匹配值可以通过数字 `n` 来查看 （`n` 是一个数字，表示第 `n` 个捕获组的内容）**

##### 例子

```
(([1-9])([a-z]+)) #匹配一个数字开头多字母(非零字母)结尾串
```

![](https://www.runoob.com/wp-content/uploads/2014/03/82A7298A-2A94-49E3-AA27-A7778EE89711.jpg)

**但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 `?:` 放在第一个选项前来消除这种副作用。**

**其中`?:` 是非捕获元之一，另外两个是 `?=` 和 `?!`**，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串

##### 先行断言和后行断言

先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为**"零宽"**。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。

`?=`  & `?<=` & `?!` & `?<!`

###### `?=`正向先行断言

`exp1(?= exp2)`    查找 exp2 前面的 exp1

###### `?<=`负向先行断言

`(?<=exp2)exp1`    查找exp2 后面的 exp1

###### `?!` 正向后行断言

`exp1(?!exp2) `       查找后面不是exp2的exp1

###### `?<! ` 负向后行断言

`(?<!exp2)exp1`     查找前面不是exp2 的 exp1

###### 两方面理解：

- **1、关于先行(lookahead)和后行(lookbehind)：**正则表达式引擎在执行字符串和表达式匹配时，会从头到尾（从前到后）连续扫描字符串中的字符，设想有一个扫描指针指向字符边界处并随匹配过程移动。先行断言，是当扫描指针位于某处时，引擎会尝试匹配指针还未扫过的字符，先于指针到达该字符，故称为先行。后行断言，引擎会尝试匹配指针已扫过的字符，后于指针到达该字符，故称为后行。
- **2、关于正向(positive)和负向(negative)：**正向就表示匹配括号中的表达式，负向表示不匹配。

###### 形成记忆：

- **1、先行和后行：**后行断言 **(?<=pattern)、(?<!pattern)** 中，有个小于号，同时也是箭头，对于自左至右的文本方向，这个箭头是指向后的，这也比较符合我们的习惯。把小于号去掉，就是先行断言。
- **2、正向和负向：**不等于 **(!=)**、逻辑非 **(!)** 都是用 **!**号来表示，所以有 **!** 号的形式表示不匹配、负向；将 **!** 号换成 **=** 号，就表示匹配、正向。

我们经常用正则表达式来检测一个字符串中包含某个子串，要表示一个字符串中不包含某个字符或某些字符也很容易，用 **[^...]** 形式就可以了。要表示一个字符串中不包含某个子串（由字符序列构成）就需要断言语句

###### **例如判断一句话中包含 this，但不包含 that**。

```
^((?<!that).)*this((?<!that).)*$
或 
^(.(?!that))*this(.(?!that))*$
```

如一句话以 **that** 开头、以 **that** 结尾、**that** 和 **this** 连在一起时，上述表达式就可能不胜任了

```
^(.(?<!that))*this(.(?<!that))*$
^(.(?<!that))*this((?!that).)*$
^((?!that).)*this(.(?<!that))*$
^((?!that).)*this((?!that).)*$
```

[正则表达式的先行断言(lookahead)和后行断言(lookbehind)](https://www.runoob.com/w3cnote/reg-lookahead-lookbehind.html)

#### 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲空间，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 **\n** 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。可以使用非捕获元字符 **?:**、**?=** 或 **?!** 来重写捕获，忽略对相关匹配的保存。

##### 例子

`\b([a-z]+) \1\b` 

其中`([a-z]+)` 表示匹配一个或多个字母。**第二部分是对以前捕获的子匹配的引用，即，单词的第二个匹配项正好由括号表达式匹配。`\1` 表示第一个子匹配项**，`\b` 作用单词边界元字符确保只检测整个单词。

`(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)`

解析URL

- 第一个括号子表达式包含 `http`
- 第二个括号子表达式包含 `www.runoob.com`
- 第三个括号子表达式包含 `:80`
- 第四个括号子表达式包含 `/html/html-tutorial.html`

## 修饰符

| 修饰符 | 含义                                 | 描述                                                         |
| ------ | :----------------------------------- | ------------------------------------------------------------ |
| i      | ignore - 不区分大小写                | 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 |
| g      | global- 全局匹配                     | 查找所有的匹配项。                                           |
| m      | multi line - 多行匹配                | 使边界字符 `^` 和 `$` 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 |
| s      | 特殊字符圆点 **.** 中包含换行符 `\n` | 默认情况下的圆点 **.** 是 匹配除换行符 **\n** 之外的任何字符，加上 **s** 修饰符之后, **.** 中包含换行符 \n。 |

## 元字符表格

| 字符           | 描述                                                         |
| :------------- | ------------------------------------------------------------ |
| `\`            | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。 |
| `^`            | 匹配输入字符串开始的位置。如果设置了RegExp对象的Multiline属性，`^` 也匹配`\n`或`\r`之后的位置。**在`[^]` 表示不匹配的元素** |
| `$`            | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，`$` 也匹配`\n`或`\r`之前的位置。 |
| `*`            | 匹配前面的子表达式零次或多次，等价于`{0,}`                   |
| `+`            | 匹配前面的子表达式一次或多次，等价于`{1,}`                   |
| `?`            | 匹配前面的子表达式零次或一次，等价于`{0,1}`                  |
| `{n}`          | `n `是一个非负整数。匹配确认的 `n` 次                        |
| `{n,}`         | `n` 是一个非负整数。表示至少匹配 `n` 次                      |
| `{n,m}`        | `m` 和 `n` 均是非负整数，`n <= m`。最少匹配`n` 次且最多匹配 `m` 次。**例如 `o{1,3}` 将匹配`fooooooood` 前三个`ooo` ，如果有后缀`g` 则匹配每一个`ooo`。** |
| `?`            | **当该字符紧跟在任何一个其他限制符(*,+,?,{n},{n,},{n,m}) 后面时，匹配模式是非贪婪的。**非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串，例如`foooooooood` 的 `o(1,3)?`只会将第一个 o 标记 |
| `.`            | 匹配除换行符 `\n \r` 之外的任何单个字符。要匹配包括 `\n` 在内的任何字符，使用 `(.|\n)` |
| `(pattern)`    | 匹配 `pattern` 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到 |
| `(?:pattern)`  | 匹配`pattern` 但不获取匹配结果，这就是一个非获取匹配，不进行存储供以后使用。在使用`(|)` 来组合一个模式的各个部分是很有用的。例如， `industr(?:y|ies)` 就是一个比 `industry|industries`更简略的表达式。 |
| `(?=pattern)`  | 正向肯定预查，在任何匹配 `pattern` 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，`Windows(?=95|98|NT|2000)`能匹配`Windows2000`中的`Windows`，但不能匹配`Windows3.1`中的 `Windows`。**?预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。?** |
| `(?!pattern)`  | 正向否定预查，在任何不配`pattern` 的字符串开始处匹配查找字符串，一个非获取匹配，**同上** |
| `(?<=pattern)` | 反向肯定预查，在任何匹配 `pattern` 的字符串开始处查找字符串，与正向肯定预查类似，只是方向相反。例如 `(?<=95|98|2000)windows`可以匹配`95windows`中的`windows`。 |
| `(?<!pattern)` | 反向否定预查，在任何不配`pattern` 的字符串开始处匹配查找字符串，与正向否定预查类似，只是方向相反。例如 `(?<!95|98|2000)windows`可以匹配`3.1windows`中的`windows`。 |
| `x|y`          | 匹配 `x` 或者 `y`                                            |
| `[xyz]`        | 字符集合。匹配所包含的任意一个字符                           |
| `[^xyz]`       | 负值字符集合。匹配未包含的任意字符串                         |
| `[a-z]`        | 字符范围。匹配指定范围中任意字符                             |
| `[^a-z]`       | 负值字符范围。匹配任何不在指定范围内的任意字符               |
| `\b`           | 匹配一个单词边界，也就是指单词和空格间的位置。例如`er\b` 可以匹配`never` 中 `er` 但是不能匹配 `verb` |
| `\B`           | 匹配非单词边界。例如`er\B 可以匹配`verb` 中 `er` 但是不能匹配 `never` |
| `\cx`          | 匹配由x指明的控制字符。例如`\cM` 匹配一个`Control-M` 或回车符，x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| `\d`           | 匹配一个数字字符。等价于[0-9]                                |
| `\D`           | 匹配一个非数字字符。等价于\[^0-9]                            |
| `\f`           | 匹配一个换页符。等价于\x0c 和 \cL                            |
| `\n`           | 匹配一个换行符。等价于\x0a 和 \cJ                            |
| `\r`           | 匹配一个回车符。等价于\x0d 和 \cM                            |
| `\s`           | 匹配任何空白字符。包括空格、制表符、换页符等等。等价于 [\f\b\n\r\t\v] |
| `\S`           | 匹配任何非空白字符。等价于\[^\f\b\n\r\t\v]                   |
| `\t`           | 匹配一个制表符。等价于 \x09 和 \cl                           |
| `\v`           | 匹配一个垂直制表符。等价于 \x0b 和 \cK                       |
| `\w`           | 匹配字符、数字、下划线。等价于[A-Za-z0-9_]                   |
| `\xn`          | 匹配 n，其中 n 为十六进制转转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。 |
| `\num`         | 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。 |
| `\n`           | 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 |
| `\nm`          | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 |
| `nml`          | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |
| `\un`          | 匹配 n， 其中 n 是一个s是一个四个十六进制数字表示的`Unicode` 字符。例如， \u00A9 匹配版权符号 (?)。 |

### 邮箱匹配

```
\b[\w.%+-]+@[\w.-]+\.[a-zA-Z]{2,6}\b
```

## 匹配优先级

从左到右进行计算，并遵循优先级顺序

| 运算符                        | 描述                           |
| ----------------------------- | :----------------------------- |
| `\`                           | 转义字符                       |
| `(),(?:),(?=),[]`             | 圆括号和方括号                 |
| `*,+,?,{n},{n,},{n,m}`        | 限定符                         |
| `^, $, \任何元字符、任何字符` | 定位点和序列（即：位置和顺序） |
| `|`                           | 替换，"或"操作                 |

## 匹配规则

### 基本模式匹配

一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。

### 字符簇

所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号

### 确定重复出现

到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。

```
^[a-zA-Z0-9_]{1,}$      //包含一个以上的字母、数字或下划线的字符串
^[1-9][0-9]{0,}$        // 所有的正整数 
^\-{0,1}[0-9]{1,}$      // 所有的整数 
^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数
^\-?[0-9]{1,}\.?[0-9]{1,}$ // 所有浮点数
```

```
^[a-zA-Z0-9_]+$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]*$        // 所有的正整数 
^\-?[0-9]+$          // 所有的整数 
^[-]?[0-9]+(\.[0-9]+)?$ // 所有的浮点数
```

## 示例

### 中括号表达式

若要创建匹配字符组的一个列表，请在方括号（[ 和 ]）内放置一个或更多单个字符。当字符括在中括号内时，该列表称为"中括号表达式"。与在任何别的位置一样，普通字符在中括号内表示其本身，即，它在输入文本中匹配一次其本身。大多数特殊字符在中括号表达式内出现时失去它们的意义。

### 替换与分组

替换使用 | 字符来允许在两个或多个替换选项之间进行选择。例如，可以扩展章节标题正则表达式，以返回比章标题范围更广的匹配项。但是，这并不象您可能认为的那样简单。替换匹配 | 字符任一侧最大的表达式。

```
^Chapter|Section [1-9][0-9]{0,1}$
```

很遗憾，上面的正则表达式要么匹配行首的单词 Chapter，要么匹配行尾的单词 Section 及跟在其后的任何数字。如果输入字符串是 Chapter 22，那么上面的表达式只匹配单词 Chapter。如果输入字符串是 Section 22，那么该表达式匹配 Section 22。**因为|的优先级比较小**

若要使正则表达式更易于控制，可以使用括号来限制替换的范围，即，确保它只应用于两个单词 Chapter 和 Section。但是，括号也用于创建子表达式，并可能捕获它们以供以后使用，这一点在有关反向引用的那一节讲述。通过在上面的正则表达式的适当位置添加括号，就可以使该正则表达式匹配 Chapter 1 或 Section 3。